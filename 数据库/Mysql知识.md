# MySql 基础知识及特性

Date：2024-11-19

作者：Cary

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [MySql 基础知识及特性](#mysql-基础知识及特性)
  - [MySql 设计表](#mysql-设计表)
    - [E-R 图的构成](#e-r-图的构成)
  - [MySql 事务](#mysql-事务)
    - [事务的 ACID 特性](#事务的-acid-特性)
      - [原子性](#原子性)
      - [一致性](#一致性)
      - [隔离性](#隔离性)
      - [持久性](#持久性)
    - [只读事务](#只读事务)
    - [事务中的问题](#事务中的问题)
      - [脏读](#脏读)
      - [不可重复读](#不可重复读)
      - [可重复读](#可重复读)
      - [幻读](#幻读)
    - [事务的隔离级别](#事务的隔离级别)
      - [Read Unconmmitted](#read-unconmmitted)
      - [Read committed](#read-committed)
      - [Repeateble Read](#repeateble-read)
      - [serializable](#serializable)
  - [MySql 索引](#mysql-索引)
    - [什么情况下应该使用索引？](#什么情况下应该使用索引)
    - [什么情况下不该创建索引](#什么情况下不该创建索引)
    - [索引分类](#索引分类)
    - [聚簇索引和非聚簇索引](#聚簇索引和非聚簇索引)
    - [LnnoDB 索引实现](#lnnodb-索引实现)
    - [组合索引的最左前缀匹配原则](#组合索引的最左前缀匹配原则)
      - [违背最左原则为什么索引会失效？](#违背最左原则为什么索引会失效)
    - [前缀索引](#前缀索引)
    - [索引失效](#索引失效)
    - [索引存储在哪？](#索引存储在哪)
    - [覆盖索引与回表](#覆盖索引与回表)
  - [MySql 的常用函数](#mysql-的常用函数)
  - [Sql](#sql)
    - [模糊查询](#模糊查询)
    - [排序](#排序)
    - [分组查询](#分组查询)
    - [连接（JOIN）](#连接join)
  - [锁机制](#锁机制)
    - [锁的粒度及锁的使用方法](#锁的粒度及锁的使用方法)
      - [行锁](#行锁)
      - [表锁](#表锁)
      - [页锁](#页锁)
      - [乐观锁和悲观锁](#乐观锁和悲观锁)
      - [死锁](#死锁)
  - [约束](#约束)
    - [约束的含义](#约束的含义)
    - [约束的分类](#约束的分类)

<!-- /code_chunk_output -->

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

## MySql 设计表

### E-R 图的构成

数据库设计表的概念，需要用 E-R 模型来表示。

E-R 模型就是实体关系模型，用来描述业务的结构模型。

E-R 模型的构成：

- 1，实体：实体表示一个对象

- 2，属性：用来描述一个对象，一个对象可以有多个属性

- 3，关系：关系表示实体和实体之间的联系，关系可以是一对多，一对一，多对多。

![](https://upload-images.jianshu.io/upload_images/27448672-f5fd18a78d6ddcc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图所示，这个关系就是多对多，一个课程有多个学生，一个学生也可以有多个课程。

## MySql 事务

事务是指对数据库进行一批操作，在这一批操作中，要么全部成功，要么全部失败，不会出现部分成功的情况。

### 事务的 ACID 特性

#### 原子性

指整个过程要么全部成功，要么全部失败

#### 一致性

指一个事务必须使数据库从一个一致性状态变换到另一个一致性状态，不能在转帐时，扣了钱但对方没有增加钱。

#### 隔离性

一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

事务的隔离级别：

- 读未提交：read uncommitted

- 读已提交：read committed

- 可重复读：repeatable read

- 串行化：serializable

#### 持久性

一个事务一旦提交，对数据库中数据的改变是永久性的。

### 只读事务

表示事务中的操作都是只读操作，不会进行修改删除。

`start transaction read only;`

### 事务中的问题

#### 脏读

一个事务在执行的过程中，读到了其他事务还没有提交的数据。

#### 不可重复读

在同一事务中，多次读取同一数据返回的结果不同。

例如 a 事务查询数据，b 事务修改了这个数据，此时 a 事务再查询这个数据时会出现数据返回结果不同

#### 可重复读

一个事务操作中对于一个读取操作不管多少次，读取到的结果都是一样的。

#### 幻读

### 事务的隔离级别

![](https://upload-images.jianshu.io/upload_images/27448672-668e141684b2f867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### Read Unconmmitted

在该隔离级别中，所有事务都可以看到其他未提交事务的执行结果

#### Read committed

一个事务只能看见已经提交事务所做的改变，

#### Repeateble Read

这是 mysql 的默认事务隔离级别，确保在同一事务的多个实例在并发读取数据时，会看到同样的数据行。

#### serializable

这是最严格的事务隔离级别，解决了很多事务中的问题，但是也会带来性能上的问题。

## MySql 索引

索引的定义是帮助 MySql 高效的获取数据，类似于书籍的目录。

### 什么情况下应该使用索引？

- 在经常需要搜索的列

- 在作为主键的列上

### 什么情况下不该创建索引

- 查询很少使用的列

- 数据值很少，或重复值很高的列

- 定义为 text，image，bit 数据类型的列不该创建索引

### 索引分类

- 主键索引：一张表只能有一个主键索引，不允许重复，不允许为 NULL。

- 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可以有多个唯一索引，索引列的值必须唯一，但允许为空。

- 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入。

- 全文索引：查找文本中的关键字。

- 单例索引：一个索引只包含一个列，一个表可以有多个单例索引。

- 组合索引：一个组合索引包含两个或以上的列，查询的时候必须遵循 mysql 索引的`最左前缀`原则，既使用 where 条件时，要按照建立索引的时候字段的排列方式放置索引才会生效。

### 聚簇索引和非聚簇索引

他们不同于索引分类，聚簇指的是一种数据存储方式，这种存储方式依靠 B+树来实现，根据表的主键构造一棵 B+树且 B+树叶子节点存放的都是表的行记录时，就可以称为该主键索引为聚簇索引。

非聚簇索引是指数据和索引是分开的，B+树的叶子节点存放的不是数据表的纪录。

### LnnoDB 索引实现

Mysql 使用的是 LnnoDB 存储引擎，LnnoDB 引擎使用 B+树存储数据。

除了主键索引为聚簇索引，其他索引都为非聚簇索引。一个表中只能存在一个聚簇索引，但可以存在多个非聚簇索引。

非聚簇索引访问数据，需要二次查找，非聚簇索引的叶子节点存储的不是数据而是主键值，首先找到主键值，再通过主键值找到数据行。

### 组合索引的最左前缀匹配原则

B+树的节点存储索引顺序是从左向右存储

比如 adc_inde:(a,b,c) 是 a，b，c 三个字段的联合索引，下列 sql 执行都无法命中索引。

```
select * from table where c = '1';

select * from table where b ='1' and c ='2'
```

而以下三种情况会走索引：

```
select * from table where a = '1';

select * from table where a = '1' and b = '2';

select * from table where a = '1' and b = '2'  and c='3';

```

只有携带最左侧的 a 字段，索引才能命中。

#### 违背最左原则为什么索引会失效？

因为缺失优先级最高的索引字段后，B+树就不知道第一步该查询哪个节点。

### 前缀索引

如果查询一列的数据很长的字符列，会让索引变得大而且慢，可以从某列的开始部分字符作为索引，节省索引空间，提升效率。

### 索引失效

以错误的方式使用索引会导致索引失效

- 1，组合索引时未遵守最左原则

- 2，对索引列进行运算也会导致索引失效

- 3，or 条件只有同时为主键时才会生效，其他场景失效。

### 索引存储在哪？

索引会生成 `*.ibd`文件，存储着索引的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

### 覆盖索引与回表

覆盖索引的形式是，搜索的索引键中的字段恰好是查询的字段，就不需要做回表查询了。

**_回表_**

查询的列数据作为索引树的键值，直接在索引树中得到反馈，不用遍历叶子节点就可以得到查询的数据。

## MySql 的常用函数

- `SELECT NOW()` 返回当前日期和时间

- `SELECT ABS（X）` 返回数值的绝对值

- `SELECT ROUND(X,Y)` 将数值 x 四舍五入道 y 位的小数

- `COUNT(X)` 返回某列中的记录数

- `SUM（x）` 返回某列中数值的总和

## Sql

sql 用于操作数据库中的数据，本文讲述一些要点，一些简单的 api 会略过。

### 模糊查询

`SELECT 字段 FROM 表 WHERE 某字段 Like 条件`

关于 like 后的条件，sql 提供了两种匹配方式

1，%：表示 0 个或多个字符，可以匹配任意类型和长度的字符。

2，\_：表示任意单个字符，匹配单个任意字符。

### 排序

升序：SELECT \* FROM stu ORDER BY sage ASC;

降序：SELECT \* FROM stu ORDER BY age DESC;

### 分组查询

使用分组查询时需要使用`GROUP BY`，例如查询每个部门的工资和。

### 连接（JOIN）

- INNER JOIN：如果表中有至少一个匹配，则返回行

- LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行

- RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行

- FULL JOIN：只要其中一个表中存在匹配，则返回行

## 锁机制

### 锁的粒度及锁的使用方法

#### 行锁

行级锁是 MySql 中锁定粒度最细的一种锁，表示对当前操作行加锁，行锁能减少数据库操作的冲突。但加锁开销巨大，可能会出现死锁。行锁按照使用方式分为，共享锁和排他锁。

- 共享锁（S 锁 读锁）：

若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但是不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以读 A，但在 T 释放 A 上的锁之前不能对 A 做任何修改。

- 排它锁（X 锁 写锁）：

若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以写 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的 X 锁。这保证了其他事务在 T 释放 A 上的锁之前，不能再读取和修改 A。

#### 表锁

表级锁是 mysql 中粒度最大的一种锁，表示对当前操作的整张表加锁，资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大。

#### 页锁

页锁是 mysql 中锁定粒度介于行级和表锁之间的锁。

#### 乐观锁和悲观锁

乐观锁和悲观锁用于控制并发

- 悲观锁：

悲观锁就类似于，把数据比喻成公共卫生间，每一个线程都要先进入卫生间后上锁，出来后释放锁，其他线程才能进入。

- 乐观锁：

乐观锁会假设不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突进行检测，如果发现冲突则返回信息，让用户处理。

#### 死锁

死锁指两个或多个事务互相等待对方持有的锁，从而导致所有事务都无法继续执行的线下。

**_1，死锁的成因_**

- 事务 A 和事务 B 持有互相需要的锁，会造成死锁。

- 长事务和锁等待时间过长，会造成死锁。

- 使用 gap lock 也可能会导致死锁，在范围查询时，多个事务视图锁定同一间隙。

**_2，死锁检测和处理_**

mysql 有死锁检测，会自动检测事务是否处于死锁状态，并中止其中一个事务，进行回滚，让其他事务执行。

**_3，如何避免死锁_**

- 合理设计索引

使用合适的索引减少加锁的范围，降低死锁的发生概率。

- 减少事务的锁定时间

尽量缩短事务的执行时间，减少锁的持有时间，避免长时间占用资源

- 升级锁定的颗粒度

使用表级锁定来减少死锁发生的概率

**_4，怎么查看死锁的日志_**

通过 `show engine innodb status`

## 约束

### 约束的含义

约束是用于限制表中的数据，为了保证数据的准确性和可靠性，例如我在这个表制定了规则，那存入此表的数据就要遵守此规则。

### 约束的分类

mysql 中，主要有六种约束

- NOT NULL：非空约束，用于约束该字段的值不能为空。

- DEFAULT: 默认值约束，用于约束该字段有默认值，约束当某个字段不输入值时，自动为其添加一个手动设置的值。

- PRIMARY KEY: 主键约束，用于约束该字段的值具有唯一性，可以没有，并且是非空的。

- UNIQUE: 唯一约束，用于约束该字段的值具有唯一性，可以没有，可以为空。

- CHECK： 检查约束，用来检查数据表中，字段值是否有效。

- FOREIGN KEY: 外键约束，用于保证该字段的值必须来自于主表的关联列的值，在从表添加外键约束，用于引用主表中的某列值，例如学生的专业编号。
