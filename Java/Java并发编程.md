# Java 并发编程

Date：2024-12-04

作者：Cary

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Java 并发编程](#java-并发编程)
  - [进程和线程](#进程和线程)
  - [线程状态](#线程状态)
  - [并行和并发](#并行和并发)
  - [同步和异步](#同步和异步)
    - [同步](#同步)
    - [异步](#异步)
  - [Synchronized](#synchronized)
    - [Synchronized 可以实现什么类型的锁？](#synchronized-可以实现什么类型的锁)
    - [Synchronized 的使用方式](#synchronized-的使用方式)
    - [Synchronized 和 Lock 的区别？](#synchronized-和-lock-的区别)
  - [volatile](#volatile)
  - [Lock 锁](#lock-锁)
  - [可重入锁](#可重入锁)
  - [线程安全](#线程安全)
    - [如何保证上述的线程安全？](#如何保证上述的线程安全)
    - [为什么能解决线程安全问题？](#为什么能解决线程安全问题)
  - [线程池](#线程池)

<!-- /code_chunk_output -->

## 进程和线程

**进程：**

进程有自己的内存空间，一个进程可以有多个线程。

**线程：**

进程中的执行任务，一个进程至少有一个线程。

## 线程状态

- 初始：创建了一个线程对象

- 运行：调用对象 start（）方法后就是运行状态

- 阻塞：表示线程阻塞

- 等待：进入该状态的线程需要等待其他线程做出一些特定动作

- 超时等待：在指定时间后自行返回

- 终止：表示该线程已经执行完毕

## 并行和并发

![](https://upload-images.jianshu.io/upload_images/27448672-716c190c4eb0ec2f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 同步和异步

### 同步

```
funcA() {
    // 等待函数funcB执行完成
    funcB();

    // 继续接下来的流程
}
```

这是同步的示例，其中 B 必须要等待 A 执行后 B 才会执行，并且在 B 没执行完之前，A 的后续代码不会先执行。

### 异步

还是拿刚才的两个函数举例子，异步函数的话 A 则不会等待 b 执行完成后再继续接下来的流程。

那么就有一个问题，函数 a 怎么知道函数 b 是否执行完成呢？

根据这个问题分为了两种情况：

1，调用方不关心执行结果

2，调用方后续需要知道执行结果

第一种情况不影响流程，无需讨论。

第二种情况，例如函数 b 是一个网络请求的话，我们可能会需要知道函数执行成功与否。

## Synchronized

Synchronized 是 Java 中的关键字，用于实现线程同步，确保在同一时刻只有一个线程能访问被 Synchronized 修饰的代码块或方法。

### Synchronized 可以实现什么类型的锁？

- 悲观锁： 每次访问共享的资源都会上锁

- 非公平锁：线程获取锁的顺序不一定是按照阻塞的顺序

- 可重入锁: 已经获取锁的线程可以再次获取锁

- 独占锁：该锁只能被一个线程持有，其他线程会被阻塞

### Synchronized 的使用方式

- 修饰代码块

- 修饰静态方法

- 修饰方法

### Synchronized 和 Lock 的区别？

Lock 是显式锁，需要手动开启和关闭。Synchronized 是隐式锁，可以自动释放锁。

Lock 是接口依靠 jdk 实现的，synchronized 是一个关键字，是依赖 JVM 实现的。

## volatile

volatile 也是一种同步机制用于并发场景中，但是他相比 Synchronized 更轻量级，因为它不会引起线程上下文的切换和调度。

## Lock 锁

Lock 可以和 Synchronized 实现一样的效果，但是 Lock 可以手动释放和获取锁。

## 可重入锁

可重入锁就是指线程已经获取某个锁，可以再次获取锁而不会出现死锁。

## 线程安全

Java 并发有三大特性，原子性，可见性，有序性。

- 原子性

要不一个连续的操作都成功，要不就都不成功。

- 可见性

当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值

- 有序性

程序执行的顺序按照代码的先后顺序执行

### 如何保证上述的线程安全？

使用多线程之间使用关键字 synchronized、volatile、或者 Lock 锁。

### 为什么能解决线程安全问题？

因为上锁能保证在同一时刻只有一个线程访问资源，就不会出现冲突。

## 线程池

在应用程序启动中创建一定数量的线程，并保存在线程池，当需要执行任务时，从线程池获取一个空闲的线程执行任务，任务执行完毕后返回线程池。
