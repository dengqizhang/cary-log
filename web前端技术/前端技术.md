# 前端笔记


### vue 的响应式原理怎么实现的

通过使用了 setters 和 getter 方法，追踪对象属性的读写实现的。

### nextTick（）函数你了解吗？

nextTick（）函数用于在 dom 更新后立刻执行回调函数，通常运用于在改变完 dom 后基于新的 dom 操作的场景。

### computed（）和 watch（）的区别？

computed（）是 vue 的计算属性，根据依赖变量的值做计算后做返回。而 watch（）是监听器，用于监听某个变量值的变化做处理等。

### 为什么使用 ref

在模板中，使用 ref 改变值时，vue 会自动检测变化并更新 dom，这个核心原理是基于 getter 和 setter 方法实现的。

### v-if 和 v-show

v-if 是真实的按照条件渲染，v-show 无论初始条件如何，始终都会被渲染。

### v-if 和 v-for

不能同时使用 v-for 和 v-if，两者优先级不明显，v-if 会被先执行。

### 怎么定义全局方法

可以采用处理 axios 的例子，将方法定义在一个 js 文件，然后在需要使用的页面导入使用。

### 你是如何解决跨域的？

跨域这种场景通常需要后端来解决好一点，但前端也有办法解决，通过 vue.config.js 文件来配置代理绕过跨域。

### vue 的组件通信方式有哪些？

- Props 父向子传参

- $emit 子向父传参

- pinia 公共状态组件传参

### vue 的双向绑定是怎么实现的？

通过 object.defineProperty()来劫持各个属性的 setter 和 getter，在数据发生变动时更新视图，

### 前端的三种存储方式有什么不同

- Cookie：存储的数据量小，根据设置的过期时间过期或关闭浏览器删除数据

- LocalStorage：存储量大，适合长期存储，只能手动删除

- SessionStorage：存储量大，关闭浏览器或标签页数据自动清除

### js 的事件冒泡

是指在一个嵌套元素中，你点击最里层的元素会触发外层嵌套元素的事件。

如果不想产生这种问题，可以用 stopPropagation（）函数停止传递事件。

### js 的事件委托

基于事件冒泡来讲述的话，事件冒泡有时候会非常有用，例如我在一个大盒子中有 16 个小盒子，我希望点击小盒子时，让小盒子随机加入背景颜色，这时候如果不使用冒泡的话，我就需要给 16 个小盒子都设置事件。如果我合理运用冒泡机制，我就可以在大盒子上加入事件，这样点击小盒子会冒泡到大盒子，完成我们想要的效果，这就是事件委托。

### js 的数据类型

- Number：数值型

- String：字符型

- Boolean：布尔型

- Object：对象

- Array：有序数组集合

### Es6 新特性

- 新增了变量声明 let 和 const

- 箭头函数

- 类

- 新增了 set 和 map 的数据结构

### let，const，var 有什么区别

const 声明常量，let 和 var 声明变量，区别不同的是 var 会有变量提升，会将局部变量提升到全局变量。

### 讲一下 vue 的路由守卫

路由守卫的作用通常是没有权限的访问进行重定向，比如没有登陆就跳转到登陆页面，在配置路由路径的 js 文件里配置不同的守卫规则。

### 闭包是什么

闭包是指在一个函数内部创建另一个函数并访问了父级函数的变量，通常只要使用了回调函数的都是闭包，例如在函数中创建网络请求。
